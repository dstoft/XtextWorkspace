/*
 * generated by Xtext 2.24.0
 */
package sdu.mdsd.math.interpreter.generator

import javax.swing.JOptionPane
import org.eclipse.emf.ecore.resource.Resource
import org.eclipse.xtext.generator.AbstractGenerator
import org.eclipse.xtext.generator.IFileSystemAccess2
import org.eclipse.xtext.generator.IGeneratorContext
import sdu.mdsd.math.interpreter.mathInterpreter.Div
import sdu.mdsd.math.interpreter.mathInterpreter.Factor
import sdu.mdsd.math.interpreter.mathInterpreter.MathExp
import sdu.mdsd.math.interpreter.mathInterpreter.Minus
import sdu.mdsd.math.interpreter.mathInterpreter.Mult
import sdu.mdsd.math.interpreter.mathInterpreter.Plus
import sdu.mdsd.math.interpreter.mathInterpreter.Primary
import sdu.mdsd.math.interpreter.mathInterpreter.Exp
import sdu.mdsd.math.interpreter.mathInterpreter.Parenthesis
import sdu.mdsd.math.interpreter.mathInterpreter.impl.PrimaryImpl
import sdu.mdsd.math.interpreter.mathInterpreter.impl.NumberImpl
import sdu.mdsd.math.interpreter.mathInterpreter.impl.ParenthesisImpl
import sdu.mdsd.math.interpreter.mathInterpreter.impl.PlusImpl
import sdu.mdsd.math.interpreter.mathInterpreter.impl.MinusImpl
import sdu.mdsd.math.interpreter.mathInterpreter.impl.ExpOpImpl

/**
 * Generates code from your model files on save.
 * 
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#code-generation
 */
class MathInterpreterGenerator extends AbstractGenerator {

	override void doGenerate(Resource resource, IFileSystemAccess2 fsa, IGeneratorContext context) {
		val math = resource.allContents.filter(MathExp).next
		val result = math.compute
		System.out.println("Math expression = "+math.display)
		// For +1 score, replace with hovering, see Bettini Chapter 8
		JOptionPane.showMessageDialog(null, "result = "+result,"Math Language", JOptionPane.INFORMATION_MESSAGE)
	}
	
	//
	// Compute function: computes value of expression
	// Note: written according to illegal left-recursive grammar, requires fix
	//
	
	def static int staticCompute(MathExp math) {
		(new MathInterpreterGenerator).compute(math)
	}
	
	def int compute(MathExp math) { 
		math.exp.computeExp
	}
	
	def int computeExp(Exp exp) {
		var left = 0
		
		if(exp.left === null) {
			System.out.println("left is null!")
		}
		if(exp.operator === null) {
			System.out.println("op is null!")
		}
		if(exp.right === null) {
			System.out.println("right is null!")
		}
		
		
		switch exp.left {
			Exp: left = (exp.left as Exp).computeExp
			Factor: return (exp.left as Factor).computeFactor
			default: System.out.println("Left is default")
		}
		switch exp.operator {
			Plus: left + exp.right.computeFactor
			Minus: left - exp.right.computeFactor
			default: left
		}
	}
	
	def int computeFactor(Factor factor) {
		var left = 0
		
		switch factor.left {
			Factor: left = (factor.left as Factor).computeFactor
			Primary: left = (factor.left as Primary).computePrim
		}
		
		switch factor.operator {
			Mult: left * factor.right.computePrim
			Div: left / factor.right.computePrim
			default: left
		}
	}
	
	def int computePrim(Primary primary) { 
		switch primary {
			Number: return (primary as Number).intValue
			Parenthesis: return (primary as Parenthesis).exp.computeExp
			PrimaryImpl: return (primary as PrimaryImpl).computePrim
			default: -1000
		}
	}
	
	def int computePrim(PrimaryImpl primary) {
		switch primary {
			NumberImpl: return (primary as NumberImpl).value
			ParenthesisImpl: return (primary as ParenthesisImpl).exp.computeExp
			default: -100
		}
	}

	//
	// Display function: show complete syntax tree
	// Note: written according to illegal left-recursive grammar, requires fix
	//

	def CharSequence display(MathExp math) '''Math[«math.exp.displayExp»]'''
	//def CharSequence displayExp(Exp exp) ''''''
	def CharSequence displayExp(Exp exp) {
		switch (exp.left) {
			Exp:
				'''«(exp.left as Exp).displayExp» «exp.operator?.displayOp» «exp.right?.displayFactor»'''
			Factor:
				'''«(exp.left as Factor).displayFactor»'''
			default:
				'''Mega wow'''
		}
	} //'''Exp[«exp.left.displayPrim»,«exp.operator?.displayOp»,«exp.right?.displayExp»]'''
	def CharSequence displayFactor(Factor fac) {
		switch (fac.left) {
			Factor:
				'''«(fac.left as Factor).displayFactor» «fac.operator?.displayOp» «fac.right?.displayPrim»'''
			Primary:
				'''«(fac.left as Primary).displayPrim»'''
			default:
				'''Uber wow'''
		}
	}
	def CharSequence displayPrim(Primary primary) {
		switch (primary) {
			Number:
				'''«(primary as Number).intValue»'''
			Parenthesis:
				'''(«(primary as Parenthesis).exp.displayExp»)'''
			PrimaryImpl:
				'''«(primary as PrimaryImpl).displayPrim»'''
		}
	}
	def CharSequence displayPrim(PrimaryImpl primary)  {
		switch (primary) {
			NumberImpl:
				'''«(primary as NumberImpl).value»'''
			ParenthesisImpl:
				'''(«(primary as ParenthesisImpl).exp.displayExp»)'''
			PrimaryImpl:
				'''crazy wow'''
		}
	}
	def dispatch String displayOp(Plus op)  { "+" }
	def dispatch String displayOp(Minus op) { "-" }
	def dispatch String displayOp(Mult op) { "*" }
	def dispatch String displayOp(Div op) { "/" }
}
